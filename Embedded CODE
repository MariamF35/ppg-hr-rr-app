/*
  Example for TFT_eSPI library

  Created by Bodmer 31/12/16

  This example draws all fonts (as used by the Adafruit_GFX library) onto the
  screen. These fonts are called the GFX Free Fonts (GFXFF) in this library.

  The fonts are referenced by a short name, see the Free_Fonts.h file
  attached to this sketch.

  Other True Type fonts could be converted using the utility within the
  "fontconvert" folder inside the library. This converted has also been
  copied from the Adafruit_GFX library. 

  Since these fonts are a recent addition Adafruit do not have a tutorial
  available yet on how to use the fontconvert utility.   Linux users will
  no doubt figure it out!  In the meantime there are 48 font files to use
  in sizes from 9 point to 24 point, and in normal, bold, and italic or
  oblique styles.

  This example sketch uses both the print class and drawString() functions
  to plot text to the screen.

  Make sure LOAD_GFXFF is defined in the User_Setup.h file within the
  library folder.

  --------------------------- NOTE ----------------------------------------
  The free font encoding format does not lend itself easily to plotting
  the background without flicker. For values that changes on screen it is
  better to use Fonts 1- 8 which are encoded specifically for rapid
  drawing with background.
  -------------------------------------------------------------------------

  #########################################################################
  ###### DON'T FORGET TO UPDATE THE User_Setup.h FILE IN THE LIBRARY ######
  ######       TO SELECT YOUR DISPLAY TYPE AND ENABLE FONTS          ######
  #########################################################################
*/
/*
#define TEXT "aA MWyz~12" // Text that will be printed on screen in any font

#include "Free_Fonts.h" // Include the header file attached to this sketch

#include "SPI.h"
#include "TFT_eSPI.h"

// Use hardware SPI
TFT_eSPI tft = TFT_eSPI();

unsigned long drawTime = 0;

void setup(void) {

  tft.begin();

  tft.setRotation(1);

}

void loop() {

  // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  // Show all 48 fonts in centre of screen ( x,y coordinate 160,120)
  // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  // Where font sizes increase the screen is not cleared as the larger fonts overwrite
  // the smaller one with the background colour.

  // Set text datum to middle centre
  tft.setTextDatum(MC_DATUM);

  // Set text colour to orange with black background
  tft.setTextColor(TFT_WHITE, TFT_BLACK);
  
  tft.fillScreen(TFT_BLACK);            // Clear screen
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF1, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF1);                 // Select the font
  tft.drawString(TEXT, 160, 120, GFXFF);// Print the string name of the font
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF2, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF2);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF3, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF3);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF4, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF4);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  
  tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF5, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF5);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF6, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF6);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF7, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF7);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF8, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF8);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  
  tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF9, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF9);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF10, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF10);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF11, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF11);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF12, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF12);
    tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  
  tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF13, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF13);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF14, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF14);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF15, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF15);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF16, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF16);
    tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  
  tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF17, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF17);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF18, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF18);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF19, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF19);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF20, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF20);
    tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  
  tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF21, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF21);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF22, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF22);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF23, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF23);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF24, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF24);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  
  tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF25, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF25);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF26, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF26);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF27, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF27);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF28, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF28);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  
  tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF29, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF29);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF30, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF30);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF31, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF31);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF32, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF32);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  
  tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF33, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF33);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF34, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF34);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF35, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF35);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF36, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF36);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  
  tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF37, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF37);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF38, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF38);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF39, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF39);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF40, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF40);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  
  tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF41, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF41);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF42, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF42);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF43, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF43);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF44, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF44);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  
  tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF45, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF45);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF46, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF46);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF47, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF47);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);
  //tft.fillScreen(TFT_BLACK);
  tft.setFreeFont(FF18);                 // Select the font
  tft.drawString(sFF48, 160, 60, GFXFF);// Print the string name of the font
  tft.setFreeFont(FF48);
  tft.drawString(TEXT, 160, 120, GFXFF);
  delay(1000);

}

// There follows a crude way of flagging that this example sketch needs fonts which
// have not been enabled in the User_Setup.h file inside the TFT_HX8357 library.
//
// These lines produce errors during compile time if settings in User_Setup are not correct
//
// The error will be "does not name a type" but ignore this and read the text between ''
// it will indicate which font or feature needs to be enabled
//
// Either delete all the following lines if you do not want warnings, or change the lines
// to suit your sketch modifications.

#ifndef LOAD_GLCD
//ERROR_Please_enable_LOAD_GLCD_in_User_Setup
#endif

#ifndef LOAD_GFXFF
ERROR_Please_enable_LOAD_GFXFF_in_User_Setup!
#endif

*/

/*
#include <TFT_eSPI.h>
#include <SPI.h>

TFT_eSPI tft = TFT_eSPI();

// Your calibration data
uint16_t calData[5] = { 191, 3623, 331, 3472, 1 };

uint16_t lastX = 0, lastY = 0;
bool touching = false;

void setup() {
  Serial.begin(115200);

  tft.begin();
  tft.setRotation(1);          // Landscape
  tft.setTouch(calData);       // Apply calibration

  tft.fillScreen(TFT_BLACK);
  tft.setTextColor(TFT_WHITE, TFT_BLACK);
  tft.drawString("Touch & Draw", 10, 10, 2);
}

void loop() {
  uint16_t x, y;

  if (tft.getTouch(&x, &y)) {

    if (!touching) {
      lastX = x;
      lastY = y;
      touching = true;
    }

    // Draw while dragging
    tft.drawLine(lastX, lastY, x, y, TFT_GREEN);

    lastX = x;
    lastY = y;
  }
  else {
    touching = false;
  }
}

*/


/*

#include <WiFi.h>
#include <PubSubClient.h>
#include <TFT_eSPI.h>

// ================== SENSOR ==================
#define PULSE_PIN 32

// ================== WIFI ==================
const char* ssid = "XplOrion 2.4G";
const char* pass = "aman_1234";

// ================== MQTT ==================
const char* mqttServer = "b37.mqtt.one";
const int   mqttPort   = 1883;
const char* mqttUser   = "40akos9672";
const char* mqttPass   = "7adefgipuv";
const char* pubTopic   = "40akos9672/esppublish";
const char* subTopic   = "40akos9672/espsubscribe";

// ================== OBJECTS ==================
WiFiClient espClient;
PubSubClient mqtt(espClient);
TFT_eSPI tft = TFT_eSPI();

// ================== TOUCH CAL ==================
uint16_t calData[5] = { 191, 3623, 331, 3472, 1 };

// ================== MODES ==================
enum Mode { MODE_IDLE, MODE_SERVER, MODE_OFFLINE, MODE_PAUSE };
Mode currentMode = MODE_IDLE;

// ================== BPM ==================
unsigned long lastBeatTime = 0;
unsigned long lastPublish  = 0;
int bpm = 0;
int prevSample = 0;

// ================== GRAPH ==================
#define GRAPH_X  65
#define GRAPH_Y  10
#define GRAPH_W  245
#define GRAPH_H  170
int graphX = GRAPH_X + 2;
int lastZone = -1;

// ================== UI ==================
#define BTN_W 55
#define BTN_H 60

// ================== HELPERS ==================
void showCenterMsg(const char* msg, uint16_t color) {
  tft.fillScreen(TFT_BLACK);
  tft.setTextDatum(MC_DATUM);
  tft.setTextColor(color, TFT_BLACK);
  tft.drawString(msg, 160, 120, 4);
}

// ================== WIFI ==================
bool connectWiFi(uint32_t timeoutMs = 8000) {
  showCenterMsg("Connecting WiFi", TFT_LIGHTGREY);
  WiFi.begin(ssid, pass);

  uint32_t start = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - start < timeoutMs) delay(100);

  showCenterMsg(WiFi.status() == WL_CONNECTED ? "WiFi Connected" : "WiFi Failed",
                WiFi.status() == WL_CONNECTED ? TFT_GREEN : TFT_RED);
  delay(1000);
  return WiFi.status() == WL_CONNECTED;
}

// ================== MQTT ==================
bool connectMQTT(uint32_t timeoutMs = 6000) {
  showCenterMsg("Connecting MQTT", TFT_LIGHTGREY);
  mqtt.setServer(mqttServer, mqttPort);

  uint32_t start = millis();
  while (!mqtt.connected() && millis() - start < timeoutMs) {
    mqtt.connect("ESP32_PULSE", mqttUser, mqttPass);
    delay(200);
  }

  if (mqtt.connected()) mqtt.subscribe(subTopic);

  showCenterMsg(mqtt.connected() ? "MQTT Connected" : "MQTT Failed",
                mqtt.connected() ? TFT_GREEN : TFT_RED);
  delay(1000);
  return mqtt.connected();
}

// ================== MQTT CALLBACK ==================
void mqttCallback(char* topic, byte* payload, unsigned int length) {
  String cmd;
  for (uint8_t i = 0; i < length; i++) cmd += (char)payload[i];

  if (cmd == "START")   currentMode = MODE_SERVER;
  if (cmd == "OFFLINE") currentMode = MODE_OFFLINE;
  if (cmd == "PAUSE")   currentMode = MODE_PAUSE;
}

// ================== UI ==================
void drawButtons() {
  tft.fillRect(0, 0, BTN_W, 240, TFT_BLACK);

  uint16_t serverColor =
    (WiFi.status() == WL_CONNECTED && mqtt.connected()) ? TFT_DARKCYAN : TFT_DARKGREY;

  tft.fillRect(5, 10, BTN_W - 10, BTN_H, serverColor);
  tft.fillRect(5, 80, BTN_W - 10, BTN_H, TFT_DARKCYAN);
  tft.fillRect(5, 150, BTN_W - 10, BTN_H, TFT_DARKCYAN);

  tft.setTextDatum(MC_DATUM);
  tft.setTextColor(TFT_WHITE, TFT_DARKCYAN);

  tft.drawString("Server", BTN_W / 2, 40, 2);
  tft.drawString("Offline", BTN_W / 2, 110, 2);
  tft.drawString("Pause", BTN_W / 2, 180, 2);
}

void drawMainUI() {
  tft.fillScreen(TFT_BLACK);
  drawButtons();
  tft.drawRect(GRAPH_X, GRAPH_Y, GRAPH_W, GRAPH_H, TFT_DARKGREY);
  graphX = GRAPH_X + 2;
  lastZone = -1;
}

// ================== GRAPH ==================
uint16_t zoneColor(int zone) {
  if (zone == 0) return TFT_NAVY;
  if (zone == 1) return TFT_DARKGREEN;
  if (zone == 2) return TFT_OLIVE;
  return TFT_MAROON;
}

void updateGraph(int value) {

  int zone;
  if (bpm < 60) zone = 0;
  else if (bpm < 90) zone = 1;
  else if (bpm < 120) zone = 2;
  else zone = 3;

  if (zone != lastZone) {
    tft.fillRect(GRAPH_X + 1, GRAPH_Y + 1,
                 GRAPH_W - 2, GRAPH_H - 2,
                 zoneColor(zone));
    lastZone = zone;
  }

  tft.drawFastVLine(graphX, GRAPH_Y + 1, GRAPH_H - 2, zoneColor(zone));

  int y = map(value, 0, 4095,
              GRAPH_Y + GRAPH_H - 2,
              GRAPH_Y + 2);

  tft.drawPixel(graphX, y, TFT_CYAN);

  graphX++;
  if (graphX >= GRAPH_X + GRAPH_W - 2)
    graphX = GRAPH_X + 2;
}

// ================== TOUCH ==================
void handleTouch() {
  uint16_t x, y;
  if (!tft.getTouch(&x, &y)) return;

  if (x < BTN_W) {
    if (y > 10 && y < 70 && WiFi.status() == WL_CONNECTED && mqtt.connected())
      currentMode = MODE_SERVER;
    else if (y > 80 && y < 140)
      currentMode = MODE_OFFLINE;
    else if (y > 150 && y < 210)
      currentMode = (currentMode == MODE_PAUSE) ? MODE_SERVER : MODE_PAUSE;

    delay(200);
  }
}

// ================== SETUP ==================
void setup() {
  Serial.begin(115200);

  tft.begin();
  tft.setRotation(1);
  tft.setTouch(calData);

  showCenterMsg("WELCOME", TFT_CYAN);
  delay(1000);

  bool wifiOK = connectWiFi();
  mqtt.setCallback(mqttCallback);
  bool mqttOK = wifiOK ? connectMQTT() : false;

  currentMode = (wifiOK && mqttOK) ? MODE_IDLE : MODE_OFFLINE;
  drawMainUI();
}

// ================== LOOP ==================
void loop() {
  mqtt.loop();
  handleTouch();

  if (currentMode == MODE_SERVER || currentMode == MODE_OFFLINE) {

    int signal = analogRead(PULSE_PIN);
    Serial.println(signal);

    if (signal > 2000 && prevSample <= 2000) {
      unsigned long now = millis();
      bpm = 60000 / (now - lastBeatTime);
      lastBeatTime = now;
    }

    prevSample = signal;
    updateGraph(signal);

    if (currentMode == MODE_SERVER && mqtt.connected() && millis() - lastPublish > 500) {
      char msg[32];
      sprintf(msg, "{\"bpm\":%d}", bpm);
      mqtt.publish(pubTopic, msg);
      lastPublish = millis();
    }
  }

  delay(20);
}
*/

/*

#include <WiFi.h>
#include <PubSubClient.h>
#include <TFT_eSPI.h>

// ================== SENSOR ==================
#define PULSE_PIN 32

// ================== WIFI ==================
const char* ssid = "XplOrion 2.4G";
const char* pass = "aman_1234";

// ================== MQTT ==================
const char* mqttServer = "b37.mqtt.one";
const int   mqttPort   = 1883;
const char* mqttUser   = "40akos9672";
const char* mqttPass   = "7adefgipuv";
const char* pubTopic   = "40akos9672/esppublish";
const char* subTopic   = "40akos9672/espsubscribe";

// ================== OBJECTS ==================
WiFiClient espClient;
PubSubClient mqtt(espClient);
TFT_eSPI tft = TFT_eSPI();

// ================== TOUCH CAL ==================
uint16_t calData[5] = { 191, 3623, 331, 3472, 1 };

// ================== MODES ==================
enum Mode { MODE_IDLE, MODE_SERVER, MODE_OFFLINE, MODE_PAUSE };
Mode currentMode = MODE_IDLE;

// ================== BPM ==================
unsigned long lastBeatTime = 0;
unsigned long lastPublish  = 0;
int bpm = 0;
int prevSample = 0;

// ================== SIGNAL PROCESSING ==================
int baseline = 2048;
float smoothFactor = 0.01;
int gain = 6;

// ================== GRAPH ==================
#define GRAPH_X  65
#define GRAPH_Y  10
#define GRAPH_W  245
#define GRAPH_H  160
int graphX = GRAPH_X + 2;
int lastZone = -1;

// ================== UI ==================
#define BTN_W 55
#define BTN_H 60

// ================== HELPERS ==================
void showCenterMsg(const char* msg, uint16_t color) {
  tft.fillScreen(TFT_BLACK);
  tft.setTextDatum(MC_DATUM);
  tft.setTextColor(color, TFT_BLACK);
  tft.drawString(msg, 160, 120, 4);
}

// ================== WIFI ==================
bool connectWiFi() {
  showCenterMsg("Connecting WiFi", TFT_LIGHTGREY);
  WiFi.begin(ssid, pass);

  uint32_t start = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - start < 8000) delay(100);

  showCenterMsg(WiFi.status() == WL_CONNECTED ? "WiFi Connected" : "WiFi Failed",
                WiFi.status() == WL_CONNECTED ? TFT_GREEN : TFT_RED);
  delay(1000);
  return WiFi.status() == WL_CONNECTED;
}

// ================== MQTT ==================
bool connectMQTT() {
  showCenterMsg("Connecting MQTT", TFT_LIGHTGREY);
  mqtt.setServer(mqttServer, mqttPort);

  uint32_t start = millis();
  while (!mqtt.connected() && millis() - start < 6000) {
    mqtt.connect("ESP32_PULSE", mqttUser, mqttPass);
    delay(200);
  }

  if (mqtt.connected()) mqtt.subscribe(subTopic);

  showCenterMsg(mqtt.connected() ? "MQTT Connected" : "MQTT Failed",
                mqtt.connected() ? TFT_GREEN : TFT_RED);
  delay(1000);
  return mqtt.connected();
}

// ================== MQTT CALLBACK ==================
void mqttCallback(char* topic, byte* payload, unsigned int length) {
  String cmd;
  for (uint8_t i = 0; i < length; i++) cmd += (char)payload[i];

  if (cmd == "START")   currentMode = MODE_SERVER;
  if (cmd == "OFFLINE") currentMode = MODE_OFFLINE;
  if (cmd == "PAUSE")   currentMode = MODE_PAUSE;
}

// ================== UI ==================
void drawButtons() {
  tft.fillRect(0, 0, BTN_W, 240, TFT_BLACK);

  uint16_t serverColor =
    (WiFi.status() == WL_CONNECTED && mqtt.connected()) ? TFT_DARKCYAN : TFT_DARKGREY;

  tft.fillRect(5, 10, BTN_W - 10, BTN_H, serverColor);
  tft.fillRect(5, 80, BTN_W - 10, BTN_H, TFT_DARKCYAN);
  tft.fillRect(5, 150, BTN_W - 10, BTN_H, TFT_DARKCYAN);

  tft.setTextDatum(MC_DATUM);
  tft.setTextColor(TFT_WHITE, TFT_DARKCYAN);

  tft.drawString("Server", BTN_W / 2, 40, 2);
  tft.drawString("Offline", BTN_W / 2, 110, 2);
  tft.drawString("Pause", BTN_W / 2, 180, 2);
}

void drawMainUI() {
  tft.fillScreen(TFT_BLACK);
  drawButtons();
  tft.drawRect(GRAPH_X, GRAPH_Y, GRAPH_W, GRAPH_H, TFT_DARKGREY);
  graphX = GRAPH_X + 2;
  lastZone = -1;
}

// ================== GRAPH ==================
uint16_t zoneColor(int zone) {
  if (zone == 0) return TFT_NAVY;
  if (zone == 1) return TFT_DARKGREEN;
  if (zone == 2) return TFT_OLIVE;
  return TFT_MAROON;
}

void updateGraph(int raw) {

  baseline = baseline * (1.0 - smoothFactor) + raw * smoothFactor;
  int amplified = (raw - baseline) * gain;
  amplified = constrain(amplified, -1800, 1800);

  int y = map(amplified, -1800, 1800,
              GRAPH_Y + GRAPH_H - 2,
              GRAPH_Y + 2);

  int zone;
  if (bpm < 60) zone = 0;
  else if (bpm < 90) zone = 1;
  else if (bpm < 120) zone = 2;
  else zone = 3;

  if (zone != lastZone) {
    tft.fillRect(GRAPH_X + 1, GRAPH_Y + 1,
                 GRAPH_W - 2, GRAPH_H - 2,
                 zoneColor(zone));
    lastZone = zone;
  }

  tft.drawFastVLine(graphX, GRAPH_Y + 1, GRAPH_H - 2, zoneColor(zone));
  tft.drawPixel(graphX, y, TFT_CYAN);

  graphX++;
  if (graphX >= GRAPH_X + GRAPH_W - 2)
    graphX = GRAPH_X + 2;
}

// ================== BPM DISPLAY ==================
void drawBPM() {
  static int lastBPM = -1;
  if (bpm == lastBPM) return;

  uint16_t color;
  if (bpm < 60) color = TFT_CYAN;
  else if (bpm < 90) color = TFT_GREEN;
  else if (bpm < 120) color = TFT_YELLOW;
  else color = TFT_RED;

  tft.fillRect(GRAPH_X, GRAPH_Y + GRAPH_H + 5, GRAPH_W, 45, TFT_BLACK);

  tft.setTextDatum(MC_DATUM);
  tft.setTextColor(color, TFT_BLACK);
  tft.drawString("BPM", GRAPH_X + GRAPH_W / 2, GRAPH_Y + GRAPH_H + 12, 2);
  tft.drawNumber(bpm, GRAPH_X + GRAPH_W / 2, GRAPH_Y + GRAPH_H + 35, 4);

  lastBPM = bpm;
}

// ================== TOUCH ==================
void handleTouch() {
  uint16_t x, y;
  if (!tft.getTouch(&x, &y)) return;

  if (x < BTN_W) {
    if (y > 10 && y < 70 && WiFi.status() == WL_CONNECTED && mqtt.connected())
      currentMode = MODE_SERVER;
    else if (y > 80 && y < 140)
      currentMode = MODE_OFFLINE;
    else if (y > 150 && y < 210)
      currentMode = (currentMode == MODE_PAUSE) ? MODE_SERVER : MODE_PAUSE;

    delay(200);
  }
}

// ================== SETUP ==================
void setup() {
  Serial.begin(115200);

  tft.begin();
  tft.setRotation(1);
  tft.setTouch(calData);

  showCenterMsg("WELCOME", TFT_CYAN);
  delay(1000);

  bool wifiOK = connectWiFi();
  mqtt.setCallback(mqttCallback);
  bool mqttOK = wifiOK ? connectMQTT() : false;

  currentMode = (wifiOK && mqttOK) ? MODE_IDLE : MODE_OFFLINE;
  drawMainUI();
}

// ================== LOOP ==================
void loop() {
  mqtt.loop();
  handleTouch();

  if (currentMode == MODE_SERVER || currentMode == MODE_OFFLINE) {

    int signal = analogRead(PULSE_PIN);
    Serial.println(signal);   // Serial Plotter

    if (signal > 2000 && prevSample <= 2000) {
      unsigned long now = millis();
      bpm = 60000 / (now - lastBeatTime);
      lastBeatTime = now;
    }

    prevSample = signal;
    updateGraph(signal);
    drawBPM();

    if (currentMode == MODE_SERVER && mqtt.connected() && millis() - lastPublish > 500) {
      char msg[32];
      sprintf(msg, "{\"bpm\":%d}", bpm);
      mqtt.publish(pubTopic, msg);
      lastPublish = millis();
    }
  }

  delay(20);
}*/




#include <WiFi.h>
#include <PubSubClient.h>
#include <TFT_eSPI.h>

// ================== SENSOR ==================
#define PULSE_PIN 32   // ADC1 pin

// ================== WIFI ==================
const char* ssid = "XplOrion 2.4G";
const char* pass = "aman_1234";

// ================== MQTT ==================
const char* mqttServer = "b37.mqtt.one";
const int   mqttPort   = 1883;
const char* mqttUser   = "40akos9672";
const char* mqttPass   = "7adefgipuv";
const char* pubTopic   = "40akos9672/esppublish";
const char* subTopic   = "40akos9672/espsubscribe";

// ================== OBJECTS ==================
WiFiClient espClient;
PubSubClient mqtt(espClient);
TFT_eSPI tft = TFT_eSPI();

// ================== TOUCH CAL ==================
uint16_t calData[5] = { 191, 3623, 331, 3472, 1 };

// ================== MODES ==================
enum Mode { MODE_IDLE, MODE_SERVER, MODE_OFFLINE, MODE_PAUSE };
Mode currentMode = MODE_IDLE;

// ================== SIGNAL PROCESSING (HW-827) ==================
float dcLevel = 2048;
float dcAlpha = 0.005;

float smoothSignal = 0;
float smoothAlpha = 0.2;

unsigned long lastBeatTime = 0;
int bpm = 0;

float dynamicThreshold = 15;
bool pulseHigh = false;

#define MIN_IBI 350  // ms

// ================== GRAPH ==================
#define GRAPH_X  65
#define GRAPH_Y  10
#define GRAPH_W  165
#define GRAPH_H  160

int graphX = GRAPH_X + 1;
int prevY  = GRAPH_Y + GRAPH_H / 2;

// ================== UI ==================
#define BTN_W 55
#define BTN_H 60

// ================== COLORS ==================
uint16_t zoneColor(int zone) {
  if (zone == 0) return TFT_NAVY;
  if (zone == 1) return TFT_DARKGREEN;
  if (zone == 2) return TFT_ORANGE;
  return TFT_RED;
}

// ================== CENTER MESSAGE ==================
void showCenterMsg(const char* msg, uint16_t color) {
  tft.fillScreen(TFT_BLACK);
  tft.setTextDatum(MC_DATUM);
  tft.setTextColor(color, TFT_BLACK);
  tft.drawString(msg, 160, 120, 4);
}

// ================== WIFI ==================
bool connectWiFi() {
  showCenterMsg("Connecting WiFi", TFT_WHITE);
  WiFi.begin(ssid, pass);

  unsigned long t0 = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - t0 < 8000) delay(100);

  showCenterMsg(
    WiFi.status() == WL_CONNECTED ? "WiFi Connected" : "WiFi Failed",
    WiFi.status() == WL_CONNECTED ? TFT_GREEN : TFT_RED
  );
  delay(1000);
  return WiFi.status() == WL_CONNECTED;
}

// ================== MQTT ==================
bool connectMQTT() {
  showCenterMsg("Connecting MQTT", TFT_WHITE);
  mqtt.setServer(mqttServer, mqttPort);

  unsigned long t0 = millis();
  while (!mqtt.connected() && millis() - t0 < 6000) {
    mqtt.connect("ESP32_PULSE", mqttUser, mqttPass);
    delay(300);
  }

  if (mqtt.connected()) mqtt.subscribe(subTopic);

  showCenterMsg(
    mqtt.connected() ? "MQTT Connected" : "MQTT Failed",
    mqtt.connected() ? TFT_GREEN : TFT_RED
  );
  delay(1000);
  return mqtt.connected();
}

// ================== MQTT CALLBACK ==================
void mqttCallback(char* topic, byte* payload, unsigned int length) {
  String cmd;
  for (uint8_t i = 0; i < length; i++) cmd += (char)payload[i];
  cmd.toUpperCase();

  if (cmd == "START") currentMode = MODE_SERVER;
  if (cmd == "OFFLINE") currentMode = MODE_OFFLINE;
  if (cmd == "PAUSE") currentMode = MODE_PAUSE;
}

// ================== UI ==================
void drawButtons() {
  tft.fillRect(0, 0, BTN_W, 240, TFT_DARKGREY);

  uint16_t serverCol =
    (WiFi.status() == WL_CONNECTED && mqtt.connected()) ? TFT_BLUE : TFT_DARKGREY;

  tft.fillRect(5, 10, BTN_W - 10, BTN_H, serverCol);
  tft.fillRect(5, 80, BTN_W - 10, BTN_H, TFT_BLUE);
  tft.fillRect(5, 150, BTN_W - 10, BTN_H, TFT_BLUE);

  tft.setTextDatum(MC_DATUM);
  tft.setTextColor(TFT_BLACK);
  tft.drawString("Server", BTN_W / 2, 40, 2);
  tft.drawString("Offline", BTN_W / 2, 110, 2);
  tft.drawString("Pause", BTN_W / 2, 180, 2);
}

void drawMainUI() {
  tft.fillScreen(TFT_BLACK);
  drawButtons();
  tft.drawRect(GRAPH_X, GRAPH_Y, GRAPH_W, GRAPH_H, TFT_WHITE);

  tft.setTextColor(TFT_CYAN, TFT_BLACK);
  tft.drawString("BPM:", GRAPH_X + 10, GRAPH_Y + GRAPH_H + 12, 2);
}

// ================== GRAPH ==================
void drawGraph(float signal) {

  float amplified = signal * 12.0;
  amplified = constrain(amplified, -200, 200);

  int y = map(amplified, -200, 200,
              GRAPH_Y + GRAPH_H - 2,
              GRAPH_Y + 2);

  tft.drawFastVLine(graphX, GRAPH_Y + 1, GRAPH_H - 2, TFT_BLACK);
  tft.drawLine(graphX - 1, prevY, graphX, y, TFT_CYAN);

  prevY = y;

  graphX++;
  if (graphX >= GRAPH_X + GRAPH_W - 1)
    graphX = GRAPH_X + 1;
}

// ================== TOUCH ==================
void handleTouch() {
  uint16_t x, y;
  if (!tft.getTouch(&x, &y)) return;

  if (x < BTN_W) {
    if (y > 10 && y < 70 && mqtt.connected())
      currentMode = MODE_SERVER;
    else if (y > 80 && y < 140)
      currentMode = MODE_OFFLINE;
    else if (y > 150 && y < 210)
      currentMode = MODE_PAUSE;

    delay(250);
  }
}

// ================== PULSE PROCESS ==================
void processPulse() {

  int raw = analogRead(PULSE_PIN);

  dcLevel = dcLevel * (1.0 - dcAlpha) + raw * dcAlpha;
  float ac = raw - dcLevel;

  smoothSignal = smoothSignal * (1.0 - smoothAlpha) + ac * smoothAlpha;

  dynamicThreshold = dynamicThreshold * 0.99 + abs(smoothSignal) * 0.01;

  unsigned long now = millis();

  if (!pulseHigh &&
      smoothSignal > dynamicThreshold &&
      now - lastBeatTime > MIN_IBI) {

    bpm = 60000 / (now - lastBeatTime);
    lastBeatTime = now;
    pulseHigh = true;

    if (currentMode == MODE_SERVER && mqtt.connected()) {
      char msg[32];
      sprintf(msg, "{\"bpm\":%d}", bpm);
      mqtt.publish(pubTopic, msg);
    }
  }

  if (smoothSignal < 0) pulseHigh = false;

  drawGraph(smoothSignal);

  tft.fillRect(GRAPH_X + 45, GRAPH_Y + GRAPH_H + 8, 60, 20, TFT_BLACK);
  tft.setTextColor(TFT_GREEN, TFT_BLACK);
  tft.drawNumber(bpm, GRAPH_X + 55, GRAPH_Y + GRAPH_H + 10, 4);
}

// ================== SETUP ==================
void setup() {
  Serial.begin(115200);

  tft.begin();
  tft.setRotation(1);
  tft.setTouch(calData);

  showCenterMsg("WELCOME", TFT_CYAN);
  delay(1000);

  bool wifiOK = connectWiFi();
  mqtt.setCallback(mqttCallback);
  if (wifiOK) connectMQTT();

  drawMainUI();
}

// ================== LOOP ==================
void loop() {
  mqtt.loop();
  handleTouch();

  if (currentMode == MODE_SERVER || currentMode == MODE_OFFLINE) {
    processPulse();
  }

  delay(15); // ~65Hz sampling
}
